
public class Memo {
	/*
	 * 点数←Hu(符)、Setting(親子、場、連荘回数、ロンツモの判定)が必要
	 * 符←Yaku(役)、Mentsu(頭、刻子、カン)、Setting(ロンツモの判定)、鳴き、待ちが必要
	 * 役←Mentsu(jan(対子、頭)、kou(刻子)、kan(カン)、shun(順子))、
	 * Setting(ロンツモ、リーチ)、dora(ドラ)、鳴き、待ち、上がり牌が必要 待ち←上がり牌、面子、使用牌 上がり牌←使用牌
	 *
	 * 面子←頭、刻子、順子、カン、待ち、上がり牌、使用牌 jan()←対子、使用牌 対子←使用牌 kou()←鳴き判定、使用牌
	 * shun()←鳴き判定、使用牌 kan()←鳴き判定、使用牌
	 *
	 * dora()←表示ドラ、有効ドラ、リーチ、kan()、使用牌、赤牌
	 *
	 * 使用牌←num(赤牌、端牌、中張牌)、ch(三元牌、翻牌) num,ch←hai(枚数)
	 *
	 * 鳴き←boolean
	 *
	 *
	 *
	 * Setting(親番、場自風、連荘回数、ロンツモの判定、リーチと順目) Dora(表示ドラ、有効ドラ、赤牌)extends
	 * Setting(リーチ) Kan 使用牌(Num,Ch) Mentsu(頭、刻子、順子、カン、待ち、上がり牌)extends Kan
	 * 使用牌(Num,Ch) Kan(使用牌、鳴き判定)extends 使用牌(Num,Ch)
	 * Yaku(面子、ロンツモ、リーチ、有効ドラ、待ち、上がり牌)
	 */
	/*
	 * The Open-Closed Principle (OCP) むすんでひらいての法則
	 *
	 * オブジェクト指向が先にきて次にOCPが来るのではなく，OCPがまずあってそれを実現するための手段としてオブジェクト指向がくる
	 *
	 *
	 * The Liskov Substitution Principle (LSP) 継承使う場合常に意識した方がよい重要な原則
	 *
	 * Meyer先生のDesign by Contractでもうちょっと厳密に表せます
	 *
	 *
	 * The Dependency Inversion Principle (DIP) 構造化プログラミングに対して依存関係が逆転してしまう，という法則
	 *
	 * 依存関係のコペルニクス的転回
	 *
	 *
	 * The Interface Segregation Principle (ISP)
	 * インターフェイスを分離せよ，インターフェイスを太らせてはいけない
	 *
	 * Adapterパターンの場合は，他のオブジェクトとお話ができるようにインターフェイスを変換しよう，ということですが，
	 * この法則が言っているのは，お話するのに必要最小限のインターフェイスしか教えないようにしよう，ということです
	 *
	 *
	 *
	 * クラスを集めたパッケージに関する原則
	 *
	 * The Reuse/Release Equivalence Principle(REP)
	 * パッケージを再利用可能にするためのシステムについて述べたもの
	 *
	 * 再利用可能にするには，クラス群をリリースする単位としてパッケージ化し，バージョン管理を行うようにすべきだ，ということ
	 *
	 *
	 * The Common Reuse Principle (CRP) パッケージに入れるクラスは何にするかという判定基準を再利用の観点から表したもの
	 *
	 * あるパッケージをバージョンアップする場合，利用している側のソフトウェアにとって
	 * 関係のないクラスが修正されたにも関わらず更新しなければならない，というのはおかしな話。
	 * パッケージをリリースしたあとの配布の問題を考えてもこうなっていることが理想。
	 * InterfaceSegregationPrincipleのパッケージ版
	 *
	 *
	 * The Common Closure Principle (CCP)
	 * 今度は，パッケージに入れるクラスは何にするかという判定基準をメンテナンス性から表したもの
	 *
	 * ソフトウェアを修正しなければならない場合，その修正があるパッケージの中で閉じているにこしたことはありません．
	 * だから，将来起こるであろう変更を想定した場合，いっしょに修正することになるクラスは同じパッケージに入れてしまったほうがよい，ということです
	 *
	 *
	 *
	 * パッケージ間の依存関係についての原則
	 *
	 * The Acyclic Dependencies Principle (ADP) 依存関係が循環してはいけない
	 *
	 * パッケージの依存関係がどこかで循環していると，それらのパッケージを単独でアップデートすることはできません．
	 * アップデートするとしたら，循環しているパッケージ全体を一度に行わなければならないのです．
	 * この原則は，必ず守らなければならないものといってよいでしょう
	 *
	 *
	 * The Stable Dependencies Principle (SDP) Stability（安定性），「変更する難易度」
	 *
	 * 安定しているパッケージは修正が難しく，不安定なパッケージは修正が容易。 パッケージの依存関係はより安定しているパッケージへと向かうべき，ということ
	 *
	 *
	 * The Stable Abstractions Principle (SAP)
	 * 今度はStabilityとAbstractionの関係。パッケージの依存関係は抽象度が高いパッケージへの向かうべき。
	 *
	 * SAP と SDP は Dependency Inversion Principleのパッケージ版
	 * パッケージからこの安定性と抽象度を数値的に測定し，Main Sequence というアイデアを導入している。
	 *
	 *
	 * The Law of Demeter（デメテルの法則） オブジェクトは直接の友達以外お話しちゃだめ，というルール。
	 *
	 * 友達の友達にまでアクセスすると，友達が勝手にそいつと縁を切った場合困る，ということ。
	 * このルールに厳密に従うにはラッパーを作らないといけないのでかなり面倒
	 *
	 */
}
